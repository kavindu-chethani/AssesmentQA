"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const get_exportable_lib_path_1 = __importDefault(require("../test-file/get-exportable-lib-path"));
function getPresetEnvForTestCodeOpts(dontUseModules) {
    const opts = {
        targets: { node: 'current' },
        loose: true,
        exclude: ['transform-regenerator'],
    };
    if (dontUseModules)
        opts.modules = false;
    return opts;
}
function getPresetEnvForClientFunctionOpts() {
    return {
        loose: true,
        exclude: ['transform-typeof-symbol', 'transform-for-of'],
    };
}
function getModuleResolverOpts(experimentalEsm) {
    return {
        resolvePath(source) {
            //NOTE: Prevent module caching to import 'fixture' and 'test' in ESM mode.
            if (source === 'testcafe')
                return (0, get_exportable_lib_path_1.default)(experimentalEsm);
            return source;
        },
    };
}
function getTransformForOfOptions() {
    // NOTE: allowArrayLike is required to allow iterating non-iterable objects (e.g. NodeList)
    // to preserve compatibility with older TestCafe code
    return { loose: true, allowArrayLike: true };
}
function getTransformRuntimeOpts() {
    // NOTE: We are forced to import helpers to each compiled file
    // because of '@babel/plugin-transform-runtime' plugin cannot correctly resolve path
    // to the helpers from the '@babel/runtime' module.
    return {
        'helpers': false,
    };
}
function getPresetReact() {
    const presetReact = require('@babel/preset-react');
    presetReact.presets = []; // disables flow so it doesn't confict w/ presetFlow
    return presetReact;
}
// NOTE: lazy load heavy dependencies
function loadLibs({ isCompilerServiceMode, experimentalEsm } = {}) {
    return {
        babel: require('@babel/core'),
        presetStage2: require('./preset-stage-2'),
        presetFlow: require('@babel/preset-flow'),
        transformRuntime: [require('@babel/plugin-transform-runtime'), getTransformRuntimeOpts()],
        transformForOfAsArray: [require('@babel/plugin-transform-for-of'), getTransformForOfOptions()],
        presetEnvForClientFunction: [require('@babel/preset-env'), getPresetEnvForClientFunctionOpts()],
        presetEnvForTestCode: [require('@babel/preset-env'), getPresetEnvForTestCodeOpts(isCompilerServiceMode || experimentalEsm)],
        moduleResolver: [require('babel-plugin-module-resolver'), getModuleResolverOpts(experimentalEsm)],
        presetReact: getPresetReact(),
        proposalPrivateMethods: [require('@babel/plugin-proposal-private-methods'), { loose: true }],
        proposalClassProperties: [require('@babel/plugin-proposal-class-properties'), { loose: true }],
    };
}
exports.default = loadLibs;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZC1saWJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBpbGVyL2JhYmVsL2xvYWQtbGlicy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG1HQUF3RTtBQUV4RSxTQUFTLDJCQUEyQixDQUFFLGNBQWM7SUFDaEQsTUFBTSxJQUFJLEdBQUc7UUFDVCxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO1FBQzVCLEtBQUssRUFBSSxJQUFJO1FBQ2IsT0FBTyxFQUFFLENBQUMsdUJBQXVCLENBQUM7S0FDckMsQ0FBQztJQUVGLElBQUksY0FBYztRQUNkLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBRXpCLE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRCxTQUFTLGlDQUFpQztJQUN0QyxPQUFPO1FBQ0gsS0FBSyxFQUFJLElBQUk7UUFDYixPQUFPLEVBQUUsQ0FBQyx5QkFBeUIsRUFBRSxrQkFBa0IsQ0FBQztLQUMzRCxDQUFDO0FBQ04sQ0FBQztBQUVELFNBQVMscUJBQXFCLENBQUUsZUFBZTtJQUMzQyxPQUFPO1FBQ0gsV0FBVyxDQUFFLE1BQU07WUFDZiwwRUFBMEU7WUFDMUUsSUFBSSxNQUFNLEtBQUssVUFBVTtnQkFDckIsT0FBTyxJQUFBLGlDQUFvQixFQUFDLGVBQWUsQ0FBQyxDQUFDO1lBRWpELE9BQU8sTUFBTSxDQUFDO1FBQ2xCLENBQUM7S0FDSixDQUFDO0FBQ04sQ0FBQztBQUVELFNBQVMsd0JBQXdCO0lBQzdCLDJGQUEyRjtJQUMzRixxREFBcUQ7SUFDckQsT0FBTyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2pELENBQUM7QUFFRCxTQUFTLHVCQUF1QjtJQUM1Qiw4REFBOEQ7SUFDOUQsb0ZBQW9GO0lBQ3BGLG1EQUFtRDtJQUNuRCxPQUFPO1FBQ0gsU0FBUyxFQUFFLEtBQUs7S0FDbkIsQ0FBQztBQUNOLENBQUM7QUFFRCxTQUFTLGNBQWM7SUFDbkIsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFFbkQsV0FBVyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsQ0FBQyxvREFBb0Q7SUFFOUUsT0FBTyxXQUFXLENBQUM7QUFDdkIsQ0FBQztBQUVELHFDQUFxQztBQUNyQyxTQUF3QixRQUFRLENBQUUsRUFBRSxxQkFBcUIsRUFBRSxlQUFlLEVBQUUsR0FBRyxFQUFFO0lBQzdFLE9BQU87UUFDSCxLQUFLLEVBQXVCLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDbEQsWUFBWSxFQUFnQixPQUFPLENBQUMsa0JBQWtCLENBQUM7UUFDdkQsVUFBVSxFQUFrQixPQUFPLENBQUMsb0JBQW9CLENBQUM7UUFDekQsZ0JBQWdCLEVBQVksQ0FBQyxPQUFPLENBQUMsaUNBQWlDLENBQUMsRUFBRSx1QkFBdUIsRUFBRSxDQUFDO1FBQ25HLHFCQUFxQixFQUFPLENBQUMsT0FBTyxDQUFDLGdDQUFnQyxDQUFDLEVBQUUsd0JBQXdCLEVBQUUsQ0FBQztRQUNuRywwQkFBMEIsRUFBRSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLGlDQUFpQyxFQUFFLENBQUM7UUFDL0Ysb0JBQW9CLEVBQVEsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsRUFBRSwyQkFBMkIsQ0FBQyxxQkFBcUIsSUFBSSxlQUFlLENBQUMsQ0FBQztRQUNqSSxjQUFjLEVBQWMsQ0FBQyxPQUFPLENBQUMsOEJBQThCLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUM3RyxXQUFXLEVBQWlCLGNBQWMsRUFBRTtRQUM1QyxzQkFBc0IsRUFBTSxDQUFDLE9BQU8sQ0FBQyx3Q0FBd0MsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDO1FBQ2hHLHVCQUF1QixFQUFLLENBQUMsT0FBTyxDQUFDLHlDQUF5QyxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUM7S0FDcEcsQ0FBQztBQUNOLENBQUM7QUFkRCwyQkFjQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRFeHBvcnRhYmxlTGliUGF0aCBmcm9tICcuLi90ZXN0LWZpbGUvZ2V0LWV4cG9ydGFibGUtbGliLXBhdGgnO1xuXG5mdW5jdGlvbiBnZXRQcmVzZXRFbnZGb3JUZXN0Q29kZU9wdHMgKGRvbnRVc2VNb2R1bGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgdGFyZ2V0czogeyBub2RlOiAnY3VycmVudCcgfSxcbiAgICAgICAgbG9vc2U6ICAgdHJ1ZSxcbiAgICAgICAgZXhjbHVkZTogWyd0cmFuc2Zvcm0tcmVnZW5lcmF0b3InXSxcbiAgICB9O1xuXG4gICAgaWYgKGRvbnRVc2VNb2R1bGVzKVxuICAgICAgICBvcHRzLm1vZHVsZXMgPSBmYWxzZTtcblxuICAgIHJldHVybiBvcHRzO1xufVxuXG5mdW5jdGlvbiBnZXRQcmVzZXRFbnZGb3JDbGllbnRGdW5jdGlvbk9wdHMgKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvb3NlOiAgIHRydWUsXG4gICAgICAgIGV4Y2x1ZGU6IFsndHJhbnNmb3JtLXR5cGVvZi1zeW1ib2wnLCAndHJhbnNmb3JtLWZvci1vZiddLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZVJlc29sdmVyT3B0cyAoZXhwZXJpbWVudGFsRXNtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzb2x2ZVBhdGggKHNvdXJjZSkge1xuICAgICAgICAgICAgLy9OT1RFOiBQcmV2ZW50IG1vZHVsZSBjYWNoaW5nIHRvIGltcG9ydCAnZml4dHVyZScgYW5kICd0ZXN0JyBpbiBFU00gbW9kZS5cbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09ICd0ZXN0Y2FmZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cG9ydGFibGVMaWJQYXRoKGV4cGVyaW1lbnRhbEVzbSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRm9yT2ZPcHRpb25zICgpIHtcbiAgICAvLyBOT1RFOiBhbGxvd0FycmF5TGlrZSBpcyByZXF1aXJlZCB0byBhbGxvdyBpdGVyYXRpbmcgbm9uLWl0ZXJhYmxlIG9iamVjdHMgKGUuZy4gTm9kZUxpc3QpXG4gICAgLy8gdG8gcHJlc2VydmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIFRlc3RDYWZlIGNvZGVcbiAgICByZXR1cm4geyBsb29zZTogdHJ1ZSwgYWxsb3dBcnJheUxpa2U6IHRydWUgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUnVudGltZU9wdHMgKCkge1xuICAgIC8vIE5PVEU6IFdlIGFyZSBmb3JjZWQgdG8gaW1wb3J0IGhlbHBlcnMgdG8gZWFjaCBjb21waWxlZCBmaWxlXG4gICAgLy8gYmVjYXVzZSBvZiAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcnVudGltZScgcGx1Z2luIGNhbm5vdCBjb3JyZWN0bHkgcmVzb2x2ZSBwYXRoXG4gICAgLy8gdG8gdGhlIGhlbHBlcnMgZnJvbSB0aGUgJ0BiYWJlbC9ydW50aW1lJyBtb2R1bGUuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgJ2hlbHBlcnMnOiBmYWxzZSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQcmVzZXRSZWFjdCAoKSB7XG4gICAgY29uc3QgcHJlc2V0UmVhY3QgPSByZXF1aXJlKCdAYmFiZWwvcHJlc2V0LXJlYWN0Jyk7XG5cbiAgICBwcmVzZXRSZWFjdC5wcmVzZXRzID0gW107IC8vIGRpc2FibGVzIGZsb3cgc28gaXQgZG9lc24ndCBjb25maWN0IHcvIHByZXNldEZsb3dcblxuICAgIHJldHVybiBwcmVzZXRSZWFjdDtcbn1cblxuLy8gTk9URTogbGF6eSBsb2FkIGhlYXZ5IGRlcGVuZGVuY2llc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZExpYnMgKHsgaXNDb21waWxlclNlcnZpY2VNb2RlLCBleHBlcmltZW50YWxFc20gfSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFiZWw6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJ0BiYWJlbC9jb3JlJyksXG4gICAgICAgIHByZXNldFN0YWdlMjogICAgICAgICAgICAgICByZXF1aXJlKCcuL3ByZXNldC1zdGFnZS0yJyksXG4gICAgICAgIHByZXNldEZsb3c6ICAgICAgICAgICAgICAgICByZXF1aXJlKCdAYmFiZWwvcHJlc2V0LWZsb3cnKSxcbiAgICAgICAgdHJhbnNmb3JtUnVudGltZTogICAgICAgICAgIFtyZXF1aXJlKCdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1ydW50aW1lJyksIGdldFRyYW5zZm9ybVJ1bnRpbWVPcHRzKCldLFxuICAgICAgICB0cmFuc2Zvcm1Gb3JPZkFzQXJyYXk6ICAgICAgW3JlcXVpcmUoJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLWZvci1vZicpLCBnZXRUcmFuc2Zvcm1Gb3JPZk9wdGlvbnMoKV0sXG4gICAgICAgIHByZXNldEVudkZvckNsaWVudEZ1bmN0aW9uOiBbcmVxdWlyZSgnQGJhYmVsL3ByZXNldC1lbnYnKSwgZ2V0UHJlc2V0RW52Rm9yQ2xpZW50RnVuY3Rpb25PcHRzKCldLFxuICAgICAgICBwcmVzZXRFbnZGb3JUZXN0Q29kZTogICAgICAgW3JlcXVpcmUoJ0BiYWJlbC9wcmVzZXQtZW52JyksIGdldFByZXNldEVudkZvclRlc3RDb2RlT3B0cyhpc0NvbXBpbGVyU2VydmljZU1vZGUgfHwgZXhwZXJpbWVudGFsRXNtKV0sXG4gICAgICAgIG1vZHVsZVJlc29sdmVyOiAgICAgICAgICAgICBbcmVxdWlyZSgnYmFiZWwtcGx1Z2luLW1vZHVsZS1yZXNvbHZlcicpLCBnZXRNb2R1bGVSZXNvbHZlck9wdHMoZXhwZXJpbWVudGFsRXNtKV0sXG4gICAgICAgIHByZXNldFJlYWN0OiAgICAgICAgICAgICAgICBnZXRQcmVzZXRSZWFjdCgpLFxuICAgICAgICBwcm9wb3NhbFByaXZhdGVNZXRob2RzOiAgICAgW3JlcXVpcmUoJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzJyksIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgIHByb3Bvc2FsQ2xhc3NQcm9wZXJ0aWVzOiAgICBbcmVxdWlyZSgnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzJyksIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgfTtcbn1cbiJdfQ==