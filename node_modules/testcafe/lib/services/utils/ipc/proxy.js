"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPCProxy = void 0;
const async_event_emitter_1 = __importDefault(require("../../../utils/async-event-emitter"));
const lodash_1 = require("lodash");
const interfaces_1 = require("./interfaces");
class IPCProxy extends async_event_emitter_1.default {
    constructor(transport) {
        super();
        this._requestCounter = 0;
        this._stopped = false;
        this._transport = transport;
        this._handlers = {};
        this._transport.read();
        this._transport.on(interfaces_1.IPCTransportEvents.data, rawPacket => this._onRead(rawPacket));
        this.on('request', data => this._onRequest(data));
    }
    async _onRead(packet) {
        if (packet.type === interfaces_1.IPCPacketType.response)
            this.emit(`response-${packet.id}`, packet);
        else
            this.emit('request', packet);
    }
    async _onRequest(requestPacket) {
        let resultData = null;
        try {
            resultData = { result: await this._handlers[requestPacket.data.name](...requestPacket.data.args) };
        }
        catch (error) {
            resultData = { error };
        }
        const responsePacket = {
            id: requestPacket.id,
            type: interfaces_1.IPCPacketType.response,
            sync: requestPacket.sync,
            data: resultData,
        };
        // NOTE: The result of long-running action can come after the compiler service was terminated.
        if (this._stopped)
            return;
        await this._transport.write(responsePacket);
    }
    _createPacket(opts) {
        return {
            id: this._requestCounter++,
            type: interfaces_1.IPCPacketType.request,
            sync: opts.sync,
            data: opts.data,
        };
    }
    _createPlainError(errorData) {
        const error = new Error(errorData.message);
        Object.assign(error, errorData);
        return error;
    }
    register(func, context = null) {
        func = (0, lodash_1.castArray)(func);
        func.forEach(fn => {
            if (this._handlers[fn.name])
                return;
            this._handlers[fn.name] = fn.bind(context);
        });
    }
    async call(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const packet = this._createPacket({ data: { name, args }, sync: false });
        const responsePromise = this.once(`response-${packet.id}`);
        await this._transport.write(packet);
        const { data } = await responsePromise;
        if ((0, interfaces_1.isIPCErrorResponse)(data))
            throw data.error;
        return data.result;
    }
    callSync(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const requestPacket = this._createPacket({ data: { name, args }, sync: true });
        this._transport.writeSync(requestPacket);
        let responsePacket = this._transport.readSync();
        while (responsePacket.id !== requestPacket.id)
            responsePacket = this._transport.readSync();
        const response = responsePacket.data;
        if ((0, interfaces_1.isIPCErrorResponse)(response))
            throw response.error;
        return response.result;
    }
    stop() {
        this._stopped = true;
    }
}
exports.IPCProxy = IPCProxy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2VydmljZXMvdXRpbHMvaXBjL3Byb3h5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDZGQUE4RDtBQUM5RCxtQ0FBbUM7QUFFbkMsNkNBU3NCO0FBUXRCLE1BQWEsUUFBUyxTQUFRLDZCQUFZO0lBTXRDLFlBQW9CLFNBQXVCO1FBQ3ZDLEtBQUssRUFBRSxDQUFDO1FBTEosb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFPeEIsSUFBSSxDQUFDLFFBQVEsR0FBSyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFFNUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFFcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQywrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDbEYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENBQUUsTUFBaUI7UUFDcEMsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLDBCQUFhLENBQUMsUUFBUTtZQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDOztZQUUzQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRU8sS0FBSyxDQUFDLFVBQVUsQ0FBRSxhQUErQjtRQUNyRCxJQUFJLFVBQVUsR0FB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Q0FBQyxJQUFJLENBQUM7UUFDeEUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUUvRSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUV6QyxJQUFJLGNBQWMsR0FBc0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVuRSxPQUFPLGNBQWMsQ0FBQyxFQUFFLEtBQUssYUFBYSxDQUFDLEVBQUU7WUFDekMsY0FBYyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFaEQsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztRQUVyQyxJQUFJLElBQUEsK0JBQWtCLEVBQUMsUUFBUSxDQUFDO1lBQzVCLE1BQU0sUUFBUSxDQUFDLEtBQUssQ0FBQztRQUV6QixPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDM0IsQ0FBQztJQUVNLElBQUk7UUFDUCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztJQUN6QixDQUFDO0NBQ0o7QUFwSEQsNEJBb0hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi8uLi8uLi91dGlscy9hc3luYy1ldmVudC1lbWl0dGVyJztcbmltcG9ydCB7IGNhc3RBcnJheSB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7XG4gICAgSVBDUGFja2V0LFxuICAgIElQQ1BhY2tldFR5cGUsXG4gICAgSVBDUmVxdWVzdFBhY2tldCxcbiAgICBJUENSZXNwb25zZVBhY2tldCxcbiAgICBJUENSZXF1ZXN0RGF0YSxcbiAgICBpc0lQQ0Vycm9yUmVzcG9uc2UsXG4gICAgSVBDVHJhbnNwb3J0RXZlbnRzLFxuICAgIElQQ1RyYW5zcG9ydCxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuXG5pbnRlcmZhY2UgUmVxdWVzdE9wdGlvbnMge1xuICAgIGRhdGE6IElQQ1JlcXVlc3REYXRhO1xuICAgIHN5bmM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBJUENQcm94eSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBfdHJhbnNwb3J0OiBJUENUcmFuc3BvcnQ7XG4gICAgcHJpdmF0ZSBfcmVxdWVzdENvdW50ZXIgPSAwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2hhbmRsZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBGdW5jdGlvbiB9O1xuICAgIHByaXZhdGUgX3N0b3BwZWQ6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKHRyYW5zcG9ydDogSVBDVHJhbnNwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fc3RvcHBlZCAgID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5yZWFkKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5vbihJUENUcmFuc3BvcnRFdmVudHMuZGF0YSwgcmF3UGFja2V0ID0+IHRoaXMuX29uUmVhZChyYXdQYWNrZXQpKTtcbiAgICAgICAgdGhpcy5vbigncmVxdWVzdCcsIGRhdGEgPT4gdGhpcy5fb25SZXF1ZXN0KGRhdGEpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9vblJlYWQgKHBhY2tldDogSVBDUGFja2V0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChwYWNrZXQudHlwZSA9PT0gSVBDUGFja2V0VHlwZS5yZXNwb25zZSlcbiAgICAgICAgICAgIHRoaXMuZW1pdChgcmVzcG9uc2UtJHtwYWNrZXQuaWR9YCwgcGFja2V0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgcGFja2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9vblJlcXVlc3QgKHJlcXVlc3RQYWNrZXQ6IElQQ1JlcXVlc3RQYWNrZXQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IHJlc3VsdERhdGEgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHREYXRhID0geyByZXN1bHQ6IGF3YWl0IHRoaXMuX2hhbmRsZXJzW3JlcXVlc3RQYWNrZXQuZGF0YS5uYW1lXSguLi5yZXF1ZXN0UGFja2V0LmRhdGEuYXJncykgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHsgZXJyb3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUGFja2V0OiBJUENSZXNwb25zZVBhY2tldCA9IHtcbiAgICAgICAgICAgIGlkOiAgIHJlcXVlc3RQYWNrZXQuaWQsXG4gICAgICAgICAgICB0eXBlOiBJUENQYWNrZXRUeXBlLnJlc3BvbnNlLFxuICAgICAgICAgICAgc3luYzogcmVxdWVzdFBhY2tldC5zeW5jLFxuXG4gICAgICAgICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE5PVEU6IFRoZSByZXN1bHQgb2YgbG9uZy1ydW5uaW5nIGFjdGlvbiBjYW4gY29tZSBhZnRlciB0aGUgY29tcGlsZXIgc2VydmljZSB3YXMgdGVybWluYXRlZC5cbiAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0LndyaXRlKHJlc3BvbnNlUGFja2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jcmVhdGVQYWNrZXQgKG9wdHM6IFJlcXVlc3RPcHRpb25zKTogSVBDUmVxdWVzdFBhY2tldCB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogICB0aGlzLl9yZXF1ZXN0Q291bnRlcisrLFxuICAgICAgICAgICAgdHlwZTogSVBDUGFja2V0VHlwZS5yZXF1ZXN0LFxuICAgICAgICAgICAgc3luYzogb3B0cy5zeW5jLFxuICAgICAgICAgICAgZGF0YTogb3B0cy5kYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZVBsYWluRXJyb3IgKGVycm9yRGF0YTogRXJyb3IpOiBFcnJvciB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBlcnJvckRhdGEpO1xuXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVnaXN0ZXIgKGZ1bmM6IEZ1bmN0aW9uIHwgRnVuY3Rpb25bXSwgY29udGV4dDogYW55ID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBmdW5jID0gY2FzdEFycmF5KGZ1bmMpO1xuXG4gICAgICAgIGZ1bmMuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZm4ubmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tmbi5uYW1lXSA9IGZuLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjYWxsICh0YXJnZXQ6IHN0cmluZ3xGdW5jdGlvbiwgLi4uYXJnczogYW55W10pOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBjb25zdCBuYW1lICAgICAgICAgICAgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6IHRhcmdldC5uYW1lO1xuICAgICAgICBjb25zdCBwYWNrZXQgICAgICAgICAgPSB0aGlzLl9jcmVhdGVQYWNrZXQoeyBkYXRhOiB7IG5hbWUsIGFyZ3MgfSwgc3luYzogZmFsc2UgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMub25jZShgcmVzcG9uc2UtJHtwYWNrZXQuaWR9YCk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0LndyaXRlKHBhY2tldCk7XG5cbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCByZXNwb25zZVByb21pc2U7XG5cbiAgICAgICAgaWYgKGlzSVBDRXJyb3JSZXNwb25zZShkYXRhKSlcbiAgICAgICAgICAgIHRocm93IGRhdGEuZXJyb3I7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBjYWxsU3luYyAodGFyZ2V0OiBzdHJpbmd8RnVuY3Rpb24sIC4uLmFyZ3M6IGFueVtdKTogYW55IHtcbiAgICAgICAgY29uc3QgbmFtZSAgICAgICAgICA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQYWNrZXQgPSB0aGlzLl9jcmVhdGVQYWNrZXQoeyBkYXRhOiB7IG5hbWUsIGFyZ3MgfSwgc3luYzogdHJ1ZSB9KTtcblxuICAgICAgICB0aGlzLl90cmFuc3BvcnQud3JpdGVTeW5jKHJlcXVlc3RQYWNrZXQpO1xuXG4gICAgICAgIGxldCByZXNwb25zZVBhY2tldDogSVBDUmVzcG9uc2VQYWNrZXQgPSB0aGlzLl90cmFuc3BvcnQucmVhZFN5bmMoKTtcblxuICAgICAgICB3aGlsZSAocmVzcG9uc2VQYWNrZXQuaWQgIT09IHJlcXVlc3RQYWNrZXQuaWQpXG4gICAgICAgICAgICByZXNwb25zZVBhY2tldCA9IHRoaXMuX3RyYW5zcG9ydC5yZWFkU3luYygpO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VQYWNrZXQuZGF0YTtcblxuICAgICAgICBpZiAoaXNJUENFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSlcbiAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0b3AgKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG59XG4iXX0=