"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const phase_1 = __importDefault(require("../test-run/phase"));
const process_test_fn_error_1 = __importDefault(require("../errors/process-test-fn-error"));
const execute_fn_with_timeout_1 = __importDefault(require("../utils/execute-fn-with-timeout"));
class FixtureHookController {
    constructor(tests, browserConnectionCount) {
        this._fixtureMap = FixtureHookController._createFixtureMap(tests, browserConnectionCount);
    }
    static _ensureFixtureMapItem(fixtureMap, fixture) {
        if (!fixtureMap.has(fixture)) {
            const item = {
                started: false,
                runningFixtureBeforeHook: false,
                fixtureBeforeHookErr: null,
                pendingTestRunCount: 0,
                fixtureCtx: Object.create(null),
            };
            fixtureMap.set(fixture, item);
        }
    }
    static _createFixtureMap(tests, browserConnectionCount) {
        return tests.reduce((fixtureMap, test) => {
            const fixture = test.fixture;
            if (!test.skip) {
                FixtureHookController._ensureFixtureMapItem(fixtureMap, fixture);
                const item = fixtureMap.get(fixture);
                item.pendingTestRunCount += browserConnectionCount;
            }
            return fixtureMap;
        }, new Map());
    }
    _getFixtureMapItem(test) {
        return test.skip ? null : this._fixtureMap.get(test.fixture);
    }
    isTestBlocked(test) {
        const item = this._getFixtureMapItem(test);
        return !!item && item.runningFixtureBeforeHook;
    }
    async _runFixtureBeforeHook(item, fn, testRun) {
        if (!fn)
            return true;
        item.runningFixtureBeforeHook = true;
        try {
            await (0, execute_fn_with_timeout_1.default)(fn, testRun.executionTimeout, item.fixtureCtx);
        }
        catch (err) {
            item.fixtureBeforeHookErr = (0, process_test_fn_error_1.default)(err);
        }
        item.runningFixtureBeforeHook = false;
        return !item.fixtureBeforeHookErr;
    }
    async _runFixtureAfterHook(item, fn, testRun) {
        if (!fn)
            return;
        testRun.phase = phase_1.default.inFixtureAfterHook;
        try {
            await (0, execute_fn_with_timeout_1.default)(fn, testRun.executionTimeout, item.fixtureCtx);
        }
        catch (err) {
            testRun.addError((0, process_test_fn_error_1.default)(err));
        }
    }
    async runFixtureBeforeHookIfNecessary(testRun) {
        const fixture = testRun.test.fixture;
        const item = this._getFixtureMapItem(testRun.test);
        if (item) {
            const shouldRunBeforeHook = !item.started;
            item.started = true;
            const success = shouldRunBeforeHook
                && await this._runFixtureBeforeHook(item, fixture.globalBeforeFn, testRun)
                && await this._runFixtureBeforeHook(item, fixture.beforeFn, testRun);
            // NOTE: fail all tests in fixture if fixture.before hook has error
            if (!success && item.fixtureBeforeHookErr) {
                testRun.phase = phase_1.default.inFixtureBeforeHook;
                testRun.addError(item.fixtureBeforeHookErr);
                return false;
            }
            testRun.fixtureCtx = item.fixtureCtx;
        }
        return true;
    }
    async runFixtureAfterHookIfNecessary(testRun) {
        var _a;
        const fixture = testRun.test.fixture;
        const item = this._getFixtureMapItem(testRun.test);
        if (!item)
            return;
        item.pendingTestRunCount--;
        if (item.pendingTestRunCount !== 0)
            return;
        await this._runFixtureAfterHook(item, fixture.afterFn, testRun);
        await this._runFixtureAfterHook(item, fixture.globalAfterFn, testRun);
        if (item.fixtureCtx) {
            await ((_a = testRun.compilerService) === null || _a === void 0 ? void 0 : _a.removeFixtureCtxsFromState({
                fixtureIds: [fixture.id],
            }));
        }
        this._fixtureMap.delete(fixture);
    }
}
exports.default = FixtureHookController;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZml4dHVyZS1ob29rLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcnVubmVyL2ZpeHR1cmUtaG9vay1jb250cm9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOERBQStDO0FBQy9DLDRGQUFpRTtBQUlqRSwrRkFBb0U7QUFVcEUsTUFBcUIscUJBQXFCO0lBR3RDLFlBQW9CLEtBQWEsRUFBRSxzQkFBOEI7UUFDN0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUM5RixDQUFDO0lBRU8sTUFBTSxDQUFDLHFCQUFxQixDQUFFLFVBQXNDLEVBQUUsT0FBZ0I7UUFDMUYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDMUIsTUFBTSxJQUFJLEdBQUc7Z0JBQ1QsT0FBTyxFQUFtQixLQUFLO2dCQUMvQix3QkFBd0IsRUFBRSxLQUFLO2dCQUMvQixvQkFBb0IsRUFBTSxJQUFJO2dCQUM5QixtQkFBbUIsRUFBTyxDQUFDO2dCQUMzQixVQUFVLEVBQWdCLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO2FBQ2hELENBQUM7WUFFRixVQUFVLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNqQztJQUNMLENBQUM7SUFFTyxNQUFNLENBQUMsaUJBQWlCLENBQUUsS0FBYSxFQUFFLHNCQUE4QjtRQUMzRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDckMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUU3QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDWixxQkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsT0FBa0IsQ0FBQyxDQUFDO2dC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QyxDQUFDO2dCQUU1QyxPQUFPLEtBQUssQ0FBQzthQUNoQjtZQUVELE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUN4QztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxLQUFLLENBQUMsOEJBQThCLENBQUUsT0FBZ0I7O1FBQ3pELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBa0IsQ0FBQztRQUNoRCxNQUFNLElBQUksR0FBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRELElBQUksQ0FBQyxJQUFJO1lBQ0wsT0FBTztRQUVYLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBRTNCLElBQUksSUFBSSxDQUFDLG1CQUFtQixLQUFLLENBQUM7WUFDOUIsT0FBTztRQUVYLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRXRFLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixNQUFNLENBQUEsTUFBQSxPQUFPLENBQUMsZUFBZSwwQ0FBRSwwQkFBMEIsQ0FBQztnQkFDdEQsVUFBVSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQzthQUMzQixDQUFDLENBQUEsQ0FBQztTQUNOO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDckMsQ0FBQztDQUNKO0FBbElELHdDQWtJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBURVNUX1JVTl9QSEFTRSBmcm9tICcuLi90ZXN0LXJ1bi9waGFzZSc7XG5pbXBvcnQgcHJvY2Vzc1Rlc3RGbkVycm9yIGZyb20gJy4uL2Vycm9ycy9wcm9jZXNzLXRlc3QtZm4tZXJyb3InO1xuaW1wb3J0IFRlc3QgZnJvbSAnLi4vYXBpL3N0cnVjdHVyZS90ZXN0JztcbmltcG9ydCBGaXh0dXJlIGZyb20gJy4uL2FwaS9zdHJ1Y3R1cmUvZml4dHVyZSc7XG5pbXBvcnQgVGVzdFJ1biBmcm9tICcuLi90ZXN0LXJ1bic7XG5pbXBvcnQgZXhlY3V0ZUZuV2l0aFRpbWVvdXQgZnJvbSAnLi4vdXRpbHMvZXhlY3V0ZS1mbi13aXRoLXRpbWVvdXQnO1xuXG5pbnRlcmZhY2UgRml4dHVyZVN0YXRlIHtcbiAgICBzdGFydGVkOiBib29sZWFuO1xuICAgIHJ1bm5pbmdGaXh0dXJlQmVmb3JlSG9vazogYm9vbGVhbjtcbiAgICBmaXh0dXJlQmVmb3JlSG9va0VycjogbnVsbCB8IEVycm9yO1xuICAgIHBlbmRpbmdUZXN0UnVuQ291bnQ6IG51bWJlcjtcbiAgICBmaXh0dXJlQ3R4OiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeHR1cmVIb29rQ29udHJvbGxlciB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBfZml4dHVyZU1hcDogTWFwPEZpeHR1cmUsIEZpeHR1cmVTdGF0ZT47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKHRlc3RzOiBUZXN0W10sIGJyb3dzZXJDb25uZWN0aW9uQ291bnQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9maXh0dXJlTWFwID0gRml4dHVyZUhvb2tDb250cm9sbGVyLl9jcmVhdGVGaXh0dXJlTWFwKHRlc3RzLCBicm93c2VyQ29ubmVjdGlvbkNvdW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfZW5zdXJlRml4dHVyZU1hcEl0ZW0gKGZpeHR1cmVNYXA6IE1hcDxGaXh0dXJlLCBGaXh0dXJlU3RhdGU+LCBmaXh0dXJlOiBGaXh0dXJlKTogdm9pZCB7XG4gICAgICAgIGlmICghZml4dHVyZU1hcC5oYXMoZml4dHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZDogICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBydW5uaW5nRml4dHVyZUJlZm9yZUhvb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpeHR1cmVCZWZvcmVIb29rRXJyOiAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBwZW5kaW5nVGVzdFJ1bkNvdW50OiAgICAgIDAsXG4gICAgICAgICAgICAgICAgZml4dHVyZUN0eDogICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZml4dHVyZU1hcC5zZXQoZml4dHVyZSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBfY3JlYXRlRml4dHVyZU1hcCAodGVzdHM6IFRlc3RbXSwgYnJvd3NlckNvbm5lY3Rpb25Db3VudDogbnVtYmVyKTogTWFwPEZpeHR1cmUsIEZpeHR1cmVTdGF0ZT4ge1xuICAgICAgICByZXR1cm4gdGVzdHMucmVkdWNlKChmaXh0dXJlTWFwLCB0ZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaXh0dXJlID0gdGVzdC5maXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoIXRlc3Quc2tpcCkge1xuICAgICAgICAgICAgICAgIEZpeHR1cmVIb29rQ29udHJvbGxlci5fZW5zdXJlRml4dHVyZU1hcEl0ZW0oZml4dHVyZU1hcCwgZml4dHVyZSBhcyBGaXh0dXJlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBmaXh0dXJlTWFwLmdldChmaXh0dXJlKTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ucGVuZGluZ1Rlc3RSdW5Db3VudCArPSBicm93c2VyQ29ubmVjdGlvbkNvdW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZml4dHVyZU1hcDtcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRGaXh0dXJlTWFwSXRlbSAodGVzdDogVGVzdCk6IG51bGwgfCBGaXh0dXJlU3RhdGUgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGVzdC5za2lwID8gbnVsbCA6IHRoaXMuX2ZpeHR1cmVNYXAuZ2V0KHRlc3QuZml4dHVyZSBhcyBGaXh0dXJlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNUZXN0QmxvY2tlZCAodGVzdDogVGVzdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0Rml4dHVyZU1hcEl0ZW0odGVzdCk7XG5cbiAgICAgICAgcmV0dXJuICEhaXRlbSAmJiBpdGVtLnJ1bm5pbmdGaXh0dXJlQmVmb3JlSG9vaztcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9ydW5GaXh0dXJlQmVmb3JlSG9vayAoaXRlbTogRml4dHVyZVN0YXRlLCBmbjogRnVuY3Rpb24sIHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKCFmbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGl0ZW0ucnVubmluZ0ZpeHR1cmVCZWZvcmVIb29rID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZUZuV2l0aFRpbWVvdXQoZm4sIHRlc3RSdW4uZXhlY3V0aW9uVGltZW91dCwgaXRlbS5maXh0dXJlQ3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpdGVtLmZpeHR1cmVCZWZvcmVIb29rRXJyID0gcHJvY2Vzc1Rlc3RGbkVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtLnJ1bm5pbmdGaXh0dXJlQmVmb3JlSG9vayA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiAhaXRlbS5maXh0dXJlQmVmb3JlSG9va0VycjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9ydW5GaXh0dXJlQWZ0ZXJIb29rIChpdGVtOiBGaXh0dXJlU3RhdGUsIGZuOiBGdW5jdGlvbiB8IG51bGwsIHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCFmbilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0ZXN0UnVuLnBoYXNlID0gVEVTVF9SVU5fUEhBU0UuaW5GaXh0dXJlQWZ0ZXJIb29rO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBleGVjdXRlRm5XaXRoVGltZW91dChmbiwgdGVzdFJ1bi5leGVjdXRpb25UaW1lb3V0LCBpdGVtLmZpeHR1cmVDdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRlc3RSdW4uYWRkRXJyb3IocHJvY2Vzc1Rlc3RGbkVycm9yKGVycikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHJ1bkZpeHR1cmVCZWZvcmVIb29rSWZOZWNlc3NhcnkgKHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZml4dHVyZSA9IHRlc3RSdW4udGVzdC5maXh0dXJlIGFzIEZpeHR1cmU7XG4gICAgICAgIGNvbnN0IGl0ZW0gICAgPSB0aGlzLl9nZXRGaXh0dXJlTWFwSXRlbSh0ZXN0UnVuLnRlc3QpO1xuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSdW5CZWZvcmVIb29rID0gIWl0ZW0uc3RhcnRlZDtcblxuICAgICAgICAgICAgaXRlbS5zdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IHNob3VsZFJ1bkJlZm9yZUhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBhd2FpdCB0aGlzLl9ydW5GaXh0dXJlQmVmb3JlSG9vayhpdGVtLCBmaXh0dXJlLmdsb2JhbEJlZm9yZUZuIGFzIEZ1bmN0aW9uLCB0ZXN0UnVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGF3YWl0IHRoaXMuX3J1bkZpeHR1cmVCZWZvcmVIb29rKGl0ZW0sIGZpeHR1cmUuYmVmb3JlRm4gYXMgRnVuY3Rpb24sIHRlc3RSdW4pO1xuXG4gICAgICAgICAgICAvLyBOT1RFOiBmYWlsIGFsbCB0ZXN0cyBpbiBmaXh0dXJlIGlmIGZpeHR1cmUuYmVmb3JlIGhvb2sgaGFzIGVycm9yXG4gICAgICAgICAgICBpZiAoIXN1Y2Nlc3MgJiYgaXRlbS5maXh0dXJlQmVmb3JlSG9va0Vycikge1xuICAgICAgICAgICAgICAgIHRlc3RSdW4ucGhhc2UgPSBURVNUX1JVTl9QSEFTRS5pbkZpeHR1cmVCZWZvcmVIb29rO1xuXG4gICAgICAgICAgICAgICAgdGVzdFJ1bi5hZGRFcnJvcihpdGVtLmZpeHR1cmVCZWZvcmVIb29rRXJyKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVzdFJ1bi5maXh0dXJlQ3R4ID0gaXRlbS5maXh0dXJlQ3R4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHJ1bkZpeHR1cmVBZnRlckhvb2tJZk5lY2Vzc2FyeSAodGVzdFJ1bjogVGVzdFJ1bik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBmaXh0dXJlID0gdGVzdFJ1bi50ZXN0LmZpeHR1cmUgYXMgRml4dHVyZTtcbiAgICAgICAgY29uc3QgaXRlbSAgICA9IHRoaXMuX2dldEZpeHR1cmVNYXBJdGVtKHRlc3RSdW4udGVzdCk7XG5cbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGl0ZW0ucGVuZGluZ1Rlc3RSdW5Db3VudC0tO1xuXG4gICAgICAgIGlmIChpdGVtLnBlbmRpbmdUZXN0UnVuQ291bnQgIT09IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fcnVuRml4dHVyZUFmdGVySG9vayhpdGVtLCBmaXh0dXJlLmFmdGVyRm4sIHRlc3RSdW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9ydW5GaXh0dXJlQWZ0ZXJIb29rKGl0ZW0sIGZpeHR1cmUuZ2xvYmFsQWZ0ZXJGbiwgdGVzdFJ1bik7XG5cbiAgICAgICAgaWYgKGl0ZW0uZml4dHVyZUN0eCkge1xuICAgICAgICAgICAgYXdhaXQgdGVzdFJ1bi5jb21waWxlclNlcnZpY2U/LnJlbW92ZUZpeHR1cmVDdHhzRnJvbVN0YXRlKHtcbiAgICAgICAgICAgICAgICBmaXh0dXJlSWRzOiBbZml4dHVyZS5pZF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpeHR1cmVNYXAuZGVsZXRlKGZpeHR1cmUpO1xuICAgIH1cbn1cbiJdfQ==