"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeFailRequest = exports.safeContinueRequest = exports.safeFulfillRequest = exports.safeContinueResponse = void 0;
const debug_loggers_1 = require("../../utils/debug-loggers");
const cdp_1 = require("../utils/cdp");
const INVALID_INTERCEPTED_RESPONSE_ERROR_MSG = 'Invalid InterceptionId.';
// In some cases (a request was aborted, any page that initiated the request doesn't exist, etc.)
// Chrome Debug Protocol doesn't allow to continue request pipeline
// and raises the "Invalid InterceptionId" error.
// We use the simplest way to fix it - omit such an error.
async function connectionResetGuard(handleRequestFn, handleErrorFn) {
    try {
        await handleRequestFn();
    }
    catch (err) {
        if (err.message === INVALID_INTERCEPTED_RESPONSE_ERROR_MSG)
            return;
        handleErrorFn(err);
        throw err;
    }
}
async function safeContinueResponse(client, data) {
    const isPausedEvent = (0, cdp_1.isRequestPausedEvent)(data);
    await connectionResetGuard(async () => {
        const param = isPausedEvent
            ? { requestId: data.requestId }
            : data;
        await client.Fetch.continueResponse(param);
    }, err => {
        const formatter = isPausedEvent ? '%r' : '%s';
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.continueResponse. Unhandled error %s during processing ${formatter}`, err, data);
    });
}
exports.safeContinueResponse = safeContinueResponse;
async function safeFulfillRequest(client, fulfillInfo) {
    await connectionResetGuard(async () => {
        await client.Fetch.fulfillRequest(fulfillInfo);
    }, err => {
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.fulfillRequest. Unhandled error %s during processing %s`, err, fulfillInfo.requestId);
    });
}
exports.safeFulfillRequest = safeFulfillRequest;
async function safeContinueRequest(client, event) {
    await connectionResetGuard(async () => {
        await client.Fetch.continueRequest({ requestId: event.requestId });
    }, err => {
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.continueRequest. Unhandled error %s during processing %r`, err, event);
    });
}
exports.safeContinueRequest = safeContinueRequest;
async function safeFailRequest(client, event, errorReason = 'Aborted') {
    await connectionResetGuard(async () => {
        await client.Fetch.failRequest({
            requestId: event.requestId,
            errorReason,
        });
    }, err => {
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.failRequest. Unhandled error %s during processing %s`, err, event.requestId);
    });
}
exports.safeFailRequest = safeFailRequest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZS1hcGkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJveHlsZXNzL3JlcXVlc3QtcGlwZWxpbmUvc2FmZS1hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNkRBQWtFO0FBTWxFLHNDQUFvRDtBQUVwRCxNQUFNLHNDQUFzQyxHQUFHLHlCQUF5QixDQUFDO0FBRXpFLGlHQUFpRztBQUNqRyxtRUFBbUU7QUFDbkUsaURBQWlEO0FBQ2pELDBEQUEwRDtBQUUxRCxLQUFLLFVBQVUsb0JBQW9CLENBQUUsZUFBb0MsRUFBRSxhQUFpQztJQUN4RyxJQUFJO1FBQ0EsTUFBTSxlQUFlLEVBQUUsQ0FBQztLQUMzQjtJQUNELE9BQU8sR0FBUSxFQUFFO1FBQ2IsSUFBSSxHQUFHLENBQUMsT0FBTyxLQUFLLHNDQUFzQztZQUN0RCxPQUFPO1FBRVgsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5CLE1BQU0sR0FBRyxDQUFDO0tBQ2I7QUFDTCxDQUFDO0FBRU0sS0FBSyxVQUFVLG9CQUFvQixDQUFFLE1BQW1CLEVBQUUsSUFBa0Q7SUFDL0csTUFBTSxhQUFhLEdBQUcsSUFBQSwwQkFBb0IsRUFBQyxJQUFJLENBQUMsQ0FBQztJQUVqRCxNQUFNLG9CQUFvQixDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ2xDLE1BQU0sS0FBSyxHQUFHLGFBQWE7WUFDdkIsQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDL0IsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUVYLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7UUFDTCxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBRTlDLElBQUEscUNBQXFCLEVBQUMsZ0VBQWdFLFNBQVMsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsSCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFkRCxvREFjQztBQUVNLEtBQUssVUFBVSxrQkFBa0IsQ0FBRSxNQUFtQixFQUFFLFdBQWtDO0lBQzdGLE1BQU0sb0JBQW9CLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDbEMsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuRCxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUU7UUFDTCxJQUFBLHFDQUFxQixFQUFDLCtEQUErRCxFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkgsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBTkQsZ0RBTUM7QUFFTSxLQUFLLFVBQVUsbUJBQW1CLENBQUUsTUFBbUIsRUFBRSxLQUF5QjtJQUNyRixNQUFNLG9CQUFvQixDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ2xDLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDdkUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFO1FBQ0wsSUFBQSxxQ0FBcUIsRUFBQyxnRUFBZ0UsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDeEcsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBTkQsa0RBTUM7QUFFTSxLQUFLLFVBQVUsZUFBZSxDQUFFLE1BQW1CLEVBQUUsS0FBeUIsRUFBRSxjQUEyQixTQUFTO0lBQ3ZILE1BQU0sb0JBQW9CLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDbEMsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQztZQUMzQixTQUFTLEVBQUUsS0FBSyxDQUFDLFNBQVM7WUFDMUIsV0FBVztTQUNkLENBQUMsQ0FBQztJQUNQLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtRQUNMLElBQUEscUNBQXFCLEVBQUMsNERBQTRELEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5RyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFURCwwQ0FTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb3RvY29sQXBpIH0gZnJvbSAnY2hyb21lLXJlbW90ZS1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgcmVxdWVzdFBpcGVsaW5lTG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGVidWctbG9nZ2Vycyc7XG5pbXBvcnQgUHJvdG9jb2wgZnJvbSAnZGV2dG9vbHMtcHJvdG9jb2wnO1xuaW1wb3J0IFJlcXVlc3RQYXVzZWRFdmVudCA9IFByb3RvY29sLkZldGNoLlJlcXVlc3RQYXVzZWRFdmVudDtcbmltcG9ydCBGdWxmaWxsUmVxdWVzdFJlcXVlc3QgPSBQcm90b2NvbC5GZXRjaC5GdWxmaWxsUmVxdWVzdFJlcXVlc3Q7XG5pbXBvcnQgQ29udGludWVSZXNwb25zZVJlcXVlc3QgPSBQcm90b2NvbC5GZXRjaC5Db250aW51ZVJlc3BvbnNlUmVxdWVzdDtcbmltcG9ydCBFcnJvclJlYXNvbiA9IFByb3RvY29sLk5ldHdvcmsuRXJyb3JSZWFzb247XG5pbXBvcnQgeyBpc1JlcXVlc3RQYXVzZWRFdmVudCB9IGZyb20gJy4uL3V0aWxzL2NkcCc7XG5cbmNvbnN0IElOVkFMSURfSU5URVJDRVBURURfUkVTUE9OU0VfRVJST1JfTVNHID0gJ0ludmFsaWQgSW50ZXJjZXB0aW9uSWQuJztcblxuLy8gSW4gc29tZSBjYXNlcyAoYSByZXF1ZXN0IHdhcyBhYm9ydGVkLCBhbnkgcGFnZSB0aGF0IGluaXRpYXRlZCB0aGUgcmVxdWVzdCBkb2Vzbid0IGV4aXN0LCBldGMuKVxuLy8gQ2hyb21lIERlYnVnIFByb3RvY29sIGRvZXNuJ3QgYWxsb3cgdG8gY29udGludWUgcmVxdWVzdCBwaXBlbGluZVxuLy8gYW5kIHJhaXNlcyB0aGUgXCJJbnZhbGlkIEludGVyY2VwdGlvbklkXCIgZXJyb3IuXG4vLyBXZSB1c2UgdGhlIHNpbXBsZXN0IHdheSB0byBmaXggaXQgLSBvbWl0IHN1Y2ggYW4gZXJyb3IuXG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3Rpb25SZXNldEd1YXJkIChoYW5kbGVSZXF1ZXN0Rm46ICgpID0+IFByb21pc2U8dm9pZD4sIGhhbmRsZUVycm9yRm46IChlcnI6IGFueSkgPT4gdm9pZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVJlcXVlc3RGbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBJTlZBTElEX0lOVEVSQ0VQVEVEX1JFU1BPTlNFX0VSUk9SX01TRylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBoYW5kbGVFcnJvckZuKGVycik7XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhZmVDb250aW51ZVJlc3BvbnNlIChjbGllbnQ6IFByb3RvY29sQXBpLCBkYXRhOiBSZXF1ZXN0UGF1c2VkRXZlbnQgfCBDb250aW51ZVJlc3BvbnNlUmVxdWVzdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGlzUGF1c2VkRXZlbnQgPSBpc1JlcXVlc3RQYXVzZWRFdmVudChkYXRhKTtcblxuICAgIGF3YWl0IGNvbm5lY3Rpb25SZXNldEd1YXJkKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBpc1BhdXNlZEV2ZW50XG4gICAgICAgICAgICA/IHsgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCB9XG4gICAgICAgICAgICA6IGRhdGE7XG5cbiAgICAgICAgYXdhaXQgY2xpZW50LkZldGNoLmNvbnRpbnVlUmVzcG9uc2UocGFyYW0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGlzUGF1c2VkRXZlbnQgPyAnJXInIDogJyVzJztcblxuICAgICAgICByZXF1ZXN0UGlwZWxpbmVMb2dnZXIoYEZldGNoLmNvbnRpbnVlUmVzcG9uc2UuIFVuaGFuZGxlZCBlcnJvciAlcyBkdXJpbmcgcHJvY2Vzc2luZyAke2Zvcm1hdHRlcn1gLCBlcnIsIGRhdGEpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FmZUZ1bGZpbGxSZXF1ZXN0IChjbGllbnQ6IFByb3RvY29sQXBpLCBmdWxmaWxsSW5mbzogRnVsZmlsbFJlcXVlc3RSZXF1ZXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgY29ubmVjdGlvblJlc2V0R3VhcmQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBjbGllbnQuRmV0Y2guZnVsZmlsbFJlcXVlc3QoZnVsZmlsbEluZm8pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIHJlcXVlc3RQaXBlbGluZUxvZ2dlcihgRmV0Y2guZnVsZmlsbFJlcXVlc3QuIFVuaGFuZGxlZCBlcnJvciAlcyBkdXJpbmcgcHJvY2Vzc2luZyAlc2AsIGVyciwgZnVsZmlsbEluZm8ucmVxdWVzdElkKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhZmVDb250aW51ZVJlcXVlc3QgKGNsaWVudDogUHJvdG9jb2xBcGksIGV2ZW50OiBSZXF1ZXN0UGF1c2VkRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBjb25uZWN0aW9uUmVzZXRHdWFyZChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5GZXRjaC5jb250aW51ZVJlcXVlc3QoeyByZXF1ZXN0SWQ6IGV2ZW50LnJlcXVlc3RJZCB9KTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICByZXF1ZXN0UGlwZWxpbmVMb2dnZXIoYEZldGNoLmNvbnRpbnVlUmVxdWVzdC4gVW5oYW5kbGVkIGVycm9yICVzIGR1cmluZyBwcm9jZXNzaW5nICVyYCwgZXJyLCBldmVudCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYWZlRmFpbFJlcXVlc3QgKGNsaWVudDogUHJvdG9jb2xBcGksIGV2ZW50OiBSZXF1ZXN0UGF1c2VkRXZlbnQsIGVycm9yUmVhc29uOiBFcnJvclJlYXNvbiA9ICdBYm9ydGVkJyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IGNvbm5lY3Rpb25SZXNldEd1YXJkKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LkZldGNoLmZhaWxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogZXZlbnQucmVxdWVzdElkLFxuICAgICAgICAgICAgZXJyb3JSZWFzb24sXG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIHJlcXVlc3RQaXBlbGluZUxvZ2dlcihgRmV0Y2guZmFpbFJlcXVlc3QuIFVuaGFuZGxlZCBlcnJvciAlcyBkdXJpbmcgcHJvY2Vzc2luZyAlc2AsIGVyciwgZXZlbnQucmVxdWVzdElkKTtcbiAgICB9KTtcbn1cbiJdfQ==